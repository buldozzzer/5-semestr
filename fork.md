# Fork Bomb #

fork-бомба — вредоносная или ошибочно написанная программа, бесконечно создающая свои копии (системным вызовом fork()), которые обычно также начинают создавать свои копии и т. д.

Выполнение такой программы может вызывать большую нагрузку вычислительной системы или даже зависание системы вследствие нехватки системных ресурсов (дескрипторов процессов, памяти, процессорного времени), что и является целью.

Fork-бомбу очень трудно ликвидировать, т.к. один процесс не зависит от другого и помогает только лишь перезагрузка компьютера. Но иногда она попадает и в автозагрузку (если это указано в коде) и тогда для ее ликвидации необходимо загружаться в режиме защиты от сбоев (безопасном режиме в Windows). Но некоторые форк-бомбы можно уничтожить и без перезагрузки.

### Пример создания  Fork Bomb с использованием bash ###

Итак, код выглядит так:

	# :(){ :|:& };:

Где:
   *	:() — Определение функции.
   *	{  — Открытие функции.
   *    : — загрузка копии функции «:» в память
   *    |: — перенаправление вывода в следующую копию функции
   *	& — Помещает вызов функции в фоновом режиме, чтобы fork (дочерний процесс) не мог «умереть» вообще, тем самым это начнет есть системные ресурсы.
   *	} — Закрытие функции.
   *	; — Завершите определение функции. Т.е является разделителем команд, (командный сепаратор).
   *	: — Запускает функцию которая порождает fork bomb().
	 
Это рабочий код, но не очень читабельный. Вот пример нормального, читаемого кода:
	 
	 #!/bin/bash
	 bomb() {
	 bomb | bomb &
	 };
	 bomb
   
   Для уничтожения такой бомбы применяется ограничение колличества одновременно работающих процессов и тогда один из процессов Fork бомбы будет завершаться и на месте его будет создаваться другой процесс при достижении максимального колличества.
   
   Иная ситуация с ОС Windows, так как там нельзя ограничить колличество одновременно работающих процессов и вредоносная программа работает до полного исчерпания оперативной памяти и процессорного времени.

Напомню что для ОС Windows простая форк бомба выглядит так :

      :a
      start %0
      goto a
